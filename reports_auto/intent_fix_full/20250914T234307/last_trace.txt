=== BASH_TRAP ===
TIME: 2025-09-14T23:43:07+08:00
BASH_COMMAND: python - "$R" <<'PY'
import os, sys, json, glob, traceback, importlib.util, types, faulthandler
from pathlib import Path
import joblib, numpy as np
from scipy import sparse as sp

R = Path(sys.argv[1]); R.mkdir(parents=True, exist_ok=True)
pylog = (R/"py_run.log").open("w", encoding="utf-8")
faulthandler.enable(pylog)

def pick_pkl():
    cands=[]
    for pat in ["intent/**/artifacts/intent_pro_cal.pkl",
                "intent/**/artifacts/intent_pipeline*.pkl",
                "intent/artifacts/*.pkl"]:
        cands += [Path(p) for p in glob.glob(pat, recursive=True)]
    cands = [p for p in cands if p.is_file()]
    cands.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return cands[0] if cands else None

def write_rules_shim(width=1):
    # 先寫一個最小 shim，確保「在第一次 joblib.load 之前」__main__.rules_feat 就已經存在
    shim = f"""from __future__ import annotations
import numpy as _np
from scipy import sparse as _sp
def rules_feat(texts):
    n = len(texts); return _sp.csr_matrix((n, {int(width)}), dtype=_np.float64)
"""
    Path("vendor/rules_features.py").write_text(shim, encoding="utf-8")
    spec = importlib.util.spec_from_file_location("vendor.rules_features","vendor/rules_features.py")
    mod = importlib.util.module_from_spec(spec); sys.modules["vendor.rules_features"]=mod; spec.loader.exec_module(mod)
    import __main__ as M
    M.rules_feat = getattr(mod,"rules_feat")  # 關鍵：把同名符號綁到 __main__，讓 unpickle 命中

def unwrap(obj):
    if hasattr(obj,"predict"): return obj
    if isinstance(obj,dict):
        for k in ("pipe","pipeline","estimator","clf","model"):
            v=obj.get(k); 
            if hasattr(v,"predict"): return v
    return obj

def to_csr(X):
    if sp.issparse(X): return X.tocsr()
    if isinstance(X, np.ndarray): return sp.csr_matrix(X if X.ndim==2 else X.reshape(1,-1))
    raise TypeError(type(X).__name__)

def feature_dims(feat, xs):
    dims={}
    if hasattr(feat,"transformer_list"):
        for name, sub in feat.transformer_list:
            try: dims[name]=to_csr(sub.transform(xs)).shape[1]
            except Exception as e: dims[name]=f"ERR:{type(e).__name__}"
    return dims

def expected_n(clf):
    if hasattr(clf,"n_features_in_"): return int(clf.n_features_in_)
    if hasattr(clf,"base_estimator") and hasattr(clf.base_estimator,"n_features_in_"):
        return int(clf.base_estimator.n_features_in_)
    return None

# 先綁占位 rules_feat，避免 joblib.load 直接炸
write_rules_shim(width=1)

pkl = pick_pkl()
if not pkl:
    (R/"py_last_trace.txt").write_text("No PKL under intent/**/artifacts\n", encoding="utf-8")
    print("[FATAL] no PKL"); sys.exit(2)
print("[PKL]", pkl)

# 嘗試讀出訓練時的 rules_feat 定義，若找到就覆蓋 shim（更接近訓練行為）
code_root = Path(pkl).parent.parent  # intent/intent
src = code_root/".sma_tools"/"runtime_threshold_router.py"
if src.exists():
    txt = src.read_text(encoding="utf-8")
    import re
    m = re.search(r"(?ms)^\s*def\s+rules_feat\s*\([^)]*\):.*?(?=^\S)", txt+"\n\n")
    if m:
        Path("vendor/rules_features.py").write_text(m.group(0)+"\n", encoding="utf-8")
        spec = importlib.util.spec_from_file_location("vendor.rules_features","vendor/rules_features.py")
        mod = importlib.util.module_from_spec(spec); sys.modules["vendor.rules_features"]=mod; spec.loader.exec_module(mod)
        import __main__ as M
        M.rules_feat = getattr(mod,"rules_feat")
        print("[rules_feat] bound from bundle:", src)

# 第一次載入（此時 __main__.rules_feat 已存在，不會炸）
obj = joblib.load(pkl); est = unwrap(obj)
pre = None; clf = est
if hasattr(est,"steps"):
    steps = dict(est.steps)
    pre = steps.get("features") or steps.get("pre") or steps.get("union")
    clf = est.steps[-1][1]
print("[PIPELINE]", [(n, s.__class__.__name__) for n,s in getattr(est,"steps",[])])

# 量各分支維度
xs = ["報價與交期","技術支援","發票抬頭","退訂連結"]
dims = feature_dims(pre, xs) if pre is not None else {}
expect = expected_n(clf)
sum_before = sum(v for v in dims.values() if isinstance(v,int))
print("[EXPECTED]", expect, " [BRANCH_DIMS]", json.dumps(dims, ensure_ascii=False), " [SUM]", sum_before)

# 對齊 total：優先用 ZeroPad 分支；若沒有 pad，就重寫 shim 寬度再 reload
def save_and_smoke(estimator):
    out = Path("artifacts/intent_pipeline_aligned.pkl")
    joblib.dump(estimator, out); print("[SAVED]", out)
    zh = {"biz_quote":"報價","tech_support":"技術支援","complaint":"投訴","policy_qa":"規則詢問","profile_update":"資料異動","other":"其他"}
    tests = ["您好，想詢問報價與交期","請協助開立三聯發票抬頭","需要技術支援協助，附件連不上","退訂連結在此"]
    try:
        yp = estimator.predict(tests)
        for s,y in zip(tests, yp):
            print("   ", s, "->", f"{y} / {zh.get(str(y), str(y))}")
        (R/"sample_pred.json").write_text(json.dumps({"samples":tests,"pred":[str(x) for x in yp]}, ensure_ascii=False, indent=2), encoding="utf-8")
    except Exception:
        (R/"py_last_trace.txt").write_text(traceback.format_exc(), encoding="utf-8")

if expect and sum_before and expect!=sum_before and hasattr(pre,"transformer_list"):
    delta = expect - sum_before
    patched=False
    for i,(name, sub) in enumerate(pre.transformer_list):
        if any(k in name.lower() for k in ("pad","zero")) and hasattr(sub,"width"):
            old = int(getattr(sub,"width",1) or 1)
            setattr(sub,"width", old+delta)
            pre.transformer_list[i]=(name, sub)
            print("[PAD_ADD]", name, f"+{delta}")
            patched=True
            break
    if not patched:
        # 沒有 pad，則把 rules_feat shim 改成期望寬度（expect - word - char），再 reload 一次
        word = next((v for k,v in dims.items() if k.lower()=="word" and isinstance(v,int)), 0)
        char = next((v for k,v in dims.items() if k.lower()=="char" and isinstance(v,int)), 0)
        rules_w = max(1, expect - word - char)
        write_rules_shim(width=rules_w)
        obj2 = joblib.load(pkl); est = unwrap(obj2)  # 重新載入一次，讓新 shim 生效
        print("[rules_feat] shim resized to", rules_w)

# 診斷檔
diag={"steps":[(n,s.__class__.__name__) for n,s in getattr(est,"steps",[])],
      "branch_dims":dims,"expected_dim":expect,"sum_before":sum_before}
(R/"diagnostics.json").write_text(json.dumps(diag, ensure_ascii=False, indent=2), encoding="utf-8")

save_and_smoke(est)
PY

EXIT_CODE: 1
