=== BASH_TRAP ===
TIME: 2025-09-14T23:17:05+08:00
BASH_COMMAND: python - "$R" <<'PY'
import os, sys, json, re, traceback, faulthandler, time, glob, importlib, types
from pathlib import Path
import joblib, numpy as np
from scipy import sparse as sp

R = Path(sys.argv[1]); R.mkdir(parents=True, exist_ok=True)
py_log = (R/"py_run.log").open("w", encoding="utf-8")
faulthandler.enable(py_log)  # Python 層級崩潰也會寫入

def log(*a): print(*a, file=py_log, flush=True); print(*a, flush=True)

def pick_pkl():
    # 優先你的壓縮包那顆
    cands = []
    for pat in [
        "intent/**/artifacts/intent_pro_cal.pkl",
        "intent/**/artifacts/intent_pipeline*.pkl",
        "intent/artifacts/*.pkl",
    ]:
        cands += [Path(p) for p in glob.glob(pat, recursive=True)]
    cands = [p for p in cands if p.is_file()]
    cands.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return cands[0] if cands else None

def bind_rules_feat(code_root: Path):
    """
    把訓練時的 rules_feat 綁到 __main__ 並 vendor 一份到 vendor/rules_features.py，
    之後 unpickle 才會指到同名函式；不改核心碼。
    """
    # 你的壓縮包內：intent/intent/.sma_tools/runtime_threshold_router.py
    src = code_root/".sma_tools"/"runtime_threshold_router.py"
    if not src.exists():
        return None
    txt = src.read_text(encoding="utf-8")
    # 截出 rules_feat 定義（整段複製保存）
    # 寬鬆抓法：找到 `def rules_feat(` 開頭到下一個頂格 `def`/`class`/EOF
    m = re.search(r"(?ms)^\s*def\s+rules_feat\s*\([^)]*\):.*?(?=^\S)", txt+"\n\n")
    block = m.group(0).rstrip() if m else None
    vend = Path("vendor")/"rules_features.py"
    if block:
        vend.write_text(block+"\n", encoding="utf-8")
    # 動態載入到 __main__
    import __main__ as M
    ns = {}
    try:
        exec(block, ns, ns)
        if "rules_feat" in ns:
            M.rules_feat = ns["rules_feat"]
    except Exception as e:
        log("[rules_bind_exec_fail]", type(e).__name__, e)
    return vend if block else None

def unwrap(obj):
    if hasattr(obj,"predict"): return obj
    if isinstance(obj, dict):
        for k in ("pipe","pipeline","estimator","clf","model"):
            v = obj.get(k)
            if hasattr(v,"predict"): return v
    return obj

def to_csr(X):
    if sp.issparse(X): return X.tocsr()
    import numpy as np
    if isinstance(X, np.ndarray):
        return sp.csr_matrix(X if X.ndim==2 else X.reshape(1,-1))
    raise TypeError(f"non-numeric branch output: {type(X)}")

def feature_dims(feat, xs):
    dims = {}
    if hasattr(feat, "transformer_list"):
        for name, sub in feat.transformer_list:
            try:
                Y = to_csr(sub.transform(xs))
                dims[name] = int(Y.shape[1])
            except Exception as e:
                dims[name] = f"ERR:{type(e).__name__}"
    return dims

try:
    pkl = pick_pkl()
    if not pkl:
        (R/"last_trace.txt").write_text("No PKL under intent/**/artifacts\n", encoding="utf-8")
        print("[FATAL] 找不到 intent/**/artifacts/*.pkl"); sys.exit(2)
    print("[PKL]", pkl)

    code_root = pkl.parent.parent  # intent/intent
    print("[CODE_ROOT]", code_root)

    vend = bind_rules_feat(code_root)
    if vend: print("[rules_feat] bound & vendored:", vend)
    else:    print("[rules_feat] not found in bundle; skip bind")

    # 讓 vendor.rules_features 可被 import（給 CalibratedClassifier 內部參照）
    spec = importlib.util.spec_from_file_location("vendor.rules_features", "vendor/rules_features.py")
    if spec and spec.loader:
        mod = importlib.util.module_from_spec(spec)
        sys.modules["vendor.rules_features"] = mod
        spec.loader.exec_module(mod)
        import __main__ as M
        if not hasattr(M, "rules_feat"): M.rules_feat = getattr(mod,"rules_feat", None)

    obj = joblib.load(pkl)
    est = unwrap(obj)

    # 找 features/union
    pre = None
    if hasattr(est, "steps"):
        steps = dict(est.steps)
        pre = steps.get("features") or steps.get("pre") or steps.get("union")
        print("[PIPELINE_STEPS]", [(n, s.__class__.__name__) for n,s in est.steps])
        clf = est.steps[-1][1]
    else:
        clf = est

    expected = None
    if hasattr(clf, "n_features_in_"): expected = int(clf.n_features_in_)
    elif hasattr(clf, "base_estimator") and hasattr(clf.base_estimator, "n_features_in_"):
        expected = int(clf.base_estimator.n_features_in_)

    xs = ["報價與交期","技術支援","發票抬頭","退訂連結"]
    dims = feature_dims(pre, xs) if pre is not None else {}
    sum_before = sum(v for v in dims.values() if isinstance(v,int))

    print("[EXPECTED]", expected)
    print("[BRANCH_DIMS]", json.dumps(dims, ensure_ascii=False))
    print("[SUM_BEFORE]", sum_before)

    # 對齊：若存在 pad/zero 分支且總維度 < expected → 調整 width
    pad_fixed = None
    if expected and sum_before and expected != sum_before and hasattr(pre,"transformer_list"):
        delta = expected - sum_before
        for i,(name, sub) in enumerate(pre.transformer_list):
            n = name.lower()
            if any(k in n for k in ("pad","zero")) and hasattr(sub, "width"):
                old = int(getattr(sub, "width", 1) or 1)
                setattr(sub, "width", int(old + delta))
                pre.transformer_list[i] = (name, sub)
                pad_fixed = {"name": name, "old": old, "new": old + delta}
                print("[PAD_ADD]", name, f"+{delta}")
                break

    # 落地對齊後模型
    OUT = Path("artifacts")/"intent_pipeline_aligned.pkl"
    joblib.dump(est, OUT)
    print("[SAVED]", OUT)

    # 煙囪測 + 粗驗證
    zh = {"biz_quote":"報價", "tech_support":"技術支援", "complaint":"投訴", "policy_qa":"規則詢問", "profile_update":"資料異動", "other":"其他"}
    tests = ["您好，想詢問報價與交期","請協助開立三聯發票抬頭","需要技術支援協助，附件連不上","退訂連結在此"]
    try:
        pred = est.predict(tests)
        for s,y in zip(tests,pred):
            print("   ", s, "->", f"{y} / {zh.get(str(y), str(y))}")
        (R/"sample_pred.json").write_text(json.dumps({"samples":tests,"pred":[str(x) for x in pred]}, ensure_ascii=False, indent=2), encoding="utf-8")
    except Exception as e:
        print("[PRED_FAIL]", type(e).__name__, e)
        (R/"py_last_trace.txt").write_text(traceback.format_exc(), encoding="utf-8")

    # 診斷檔
    diag = {
      "steps": [(n, s.__class__.__name__) for n,s in getattr(est, "steps", [])],
      "branch_dims": dims,
      "expected_dim": expected,
      "sum_before": sum_before,
      "pad_fixed": pad_fixed,
    }
    (R/"diagnostics.json").write_text(json.dumps(diag, ensure_ascii=False, indent=2), encoding="utf-8")

except Exception:
    (R/"py_last_trace.txt").write_text(traceback.format_exc(), encoding="utf-8")
    raise
PY

EXIT_CODE: 1
