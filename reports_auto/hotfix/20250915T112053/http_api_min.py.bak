#!/usr/bin/env python
# -*- coding: utf-8 -*-
import json, time, sqlite3, traceback, os, sys, re
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse
from pathlib import Path
import joblib, faulthandler
try: import sma_tools.sk_zero_pad  # noqa
except Exception: sys.path.insert(0,"vendor")
try:
    import vendor.train_pro_fresh as _B  # 需已設 SMA_RULES_SRC
    _ = getattr(_B,"rules_feat",None)
except Exception: pass
SMA_DRY_RUN = os.environ.get("SMA_DRY_RUN","1")=="1"
SMA_DB = Path("reports_auto/audit.sqlite3"); SMA_DB.parent.mkdir(parents=True,exist_ok=True)
ML_PKL = os.environ.get("SMA_INTENT_ML_PKL","")
PORT = int(os.environ.get("PORT","8000"))
def ensure_db():
    con=sqlite3.connect(str(SMA_DB)); cur=con.cursor()
    cur.executescript("""
    CREATE TABLE IF NOT EXISTS actions(id INTEGER PRIMARY KEY AUTOINCREMENT, mail_id TEXT, action TEXT, params_json TEXT, status TEXT, retries INTEGER DEFAULT 0, started_at TEXT, finished_at TEXT, UNIQUE(mail_id, action));
    CREATE TABLE IF NOT EXISTS llm_calls(id INTEGER PRIMARY KEY AUTOINCREMENT, mail_id TEXT, stage TEXT, model TEXT, input_tokens INTEGER, output_tokens INTEGER, total_tokens INTEGER, latency_ms INTEGER, cost_usd REAL, request_id TEXT, created_at TEXT);
    """); con.commit(); con.close()
ensure_db()
def audit_llm(stage, model, ms, cost=0.0, mail_id=None):
    con=sqlite3.connect(str(SMA_DB)); cur=con.cursor()
    cur.execute("""INSERT INTO llm_calls(mail_id,stage,model,input_tokens,output_tokens,total_tokens,latency_ms,cost_usd,request_id,created_at)
                   VALUES (?,?,?,?,?,?,?,?,?,datetime('now'))""",(mail_id,stage,model,0,0,0,int(ms),float(cost),None)); con.commit(); con.close()
_pipe=None
def load_pipe():
    global _pipe
    if _pipe is not None: return _pipe
    if not ML_PKL or not Path(ML_PKL).exists(): raise RuntimeError(f"ML PKL not found: {ML_PKL}")
    obj=joblib.load(ML_PKL)
    _pipe=obj if hasattr(obj,"predict") else (obj.get("pipe") or obj.get("pipeline") or obj.get("estimator") or obj.get("model"))
    if not hasattr(_pipe,"predict"): raise RuntimeError("Unsupported estimator container")
    return _pipe
ACTIONS={"biz_quote":"create_quote_pdf","policy_qa":"reply_policy_sections","profile_update":"submit_change_form","tech_support":"open_ticket","complaint":"open_ticket","other":"noop"}
def rule_classify(texts):
    out=[]
    for t in texts:
        s=(t or "").lower()
        if any(k in s for k in ["報價","quote","報價單","價","交期"]): out.append("biz_quote")
        elif any(k in s for k in ["技術","support","無法連線","錯誤"]): out.append("tech_support")
        elif any(k in s for k in ["發票","抬頭"]): out.append("profile_update")
        elif any(k in s for k in ["政策","規則","條款","policy"]): out.append("policy_qa")
        elif any(k in s for k in ["客訴","抱怨","投訴"]): out.append("complaint")
        else: out.append("other")
    return out
def oai_classify(texts): return ["other"]*len(texts)
def kie_extract(texts):
    outs=[]
    for t in texts:
        phone=""; m=re.search(r'(09\d{2})[-\s]?(\d{3})[-\s]?(\d{3})',t or ""); 
        if m: phone="".join(m.groups())
        amount=""; m=re.search(r'(?:NT\$|NTD|\$|元)\s*([0-9][0-9,\.]*)',t or "")
        if m: amount=re.sub(r'[^\d]','',m.group(1))
        outs.append({"phone":phone,"amount":amount})
    return outs
class H(BaseHTTPRequestHandler):
    def _json(self, code:int, obj):
        self.send_response(code); self.send_header("Content-Type","application/json; charset=utf-8"); self.end_headers()
        self.wfile.write(json.dumps(obj,ensure_ascii=False).encode("utf-8"))
    def do_POST(self):
        p=urlparse(self.path).path; n=int(self.headers.get("Content-Length","0") or 0)
        body=self.rfile.read(n).decode("utf-8") if n>0 else "{}"
        try: req=json.loads(body)
        except Exception: return self._json(400,{"error":"invalid json"})
        try:
            if p=="/classify":
                texts=req.get("texts") or []; route=req.get("route","ml")
                t0=time.perf_counter()
                if route=="ml": yp=[str(y) for y in load_pipe().predict(texts)]; tag="ml"
                elif route=="rule": yp=rule_classify(texts); tag="rule"
                else: yp=oai_classify(texts); tag="openai"
                ms=int((time.perf_counter()-t0)*1000); audit_llm(f"{tag}.classify",tag,ms,0.0)
                return self._json(200,{"pred":yp,"latency_ms":ms,"route":tag})
            if p=="/extract":
                texts=req.get("texts") or []; t0=time.perf_counter(); out=kie_extract(texts); ms=int((time.perf_counter()-t0)*1000)
                audit_llm("rule.extract","rule",ms,0.0); return self._json(200,{"fields":out,"latency_ms":ms})
            if p=="/plan":
                intents=req.get("intents") or []; actions=[ACTIONS.get(i,"noop") for i in intents]
                audit_llm("plan","rule",0.0,0.0); return self._json(200,{"actions":actions})
            if p=="/act":
                items=req.get("items") or []; ok=0; out=Path("rpa_out"); out.mkdir(parents=True,exist_ok=True)
                for it in items:
                    mail_id=it.get("mail_id"); action=it.get("action","noop")
                    (out/f"act_{action}_{mail_id}.txt").write_text(json.dumps(it,ensure_ascii=False,indent=2),encoding="utf-8")
                    audit_llm("act",action,0.0,0.0,mail_id); ok+=1
                return self._json(200,{"ok":ok,"dry_run":os.environ.get("SMA_DRY_RUN","1")=="1"})
            if p=="/tri-eval":
                texts=req.get("texts") or []; labels=[str(x) for x in (req.get("labels") or [])]
                out=[]
                for tag,fn in (("rule",rule_classify),("ml",lambda xs:[str(y) for y in load_pipe().predict(xs)]),("openai",oai_classify)):
                    t0=time.perf_counter(); yp=[str(y) for y in fn(texts)]; ms=int((time.perf_counter()-t0)*1000); audit_llm(f"{tag}.classify",tag,ms,0.0)
                    r={"route":tag,"pred":yp,"latency_ms":ms}
                    if labels and len(labels)==len(yp):
                        acc=sum(int(a==b) for a,b in zip(labels,yp))/len(labels); r["accuracy"]=round(acc,4)
                    out.append(r)
                return self._json(200,{"n":len(texts),"runs":out})
            return self._json(404,{"error":"not found"})
        except Exception:
            return self._json(500,{"error":"server_error","trace":traceback.format_exc()})
def run():
    Path("reports_auto/api").mkdir(parents=True,exist_ok=True); faulthandler.enable()
    srv=HTTPServer(("0.0.0.0",PORT),H); print(f"[*] API on :{PORT}"); srv.serve_forever()
if __name__=="__main__": run()
