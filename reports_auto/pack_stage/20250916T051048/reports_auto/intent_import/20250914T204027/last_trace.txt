Traceback (most recent call last):
  File "<stdin>", line 104, in <module>
  File "/home/youjie/projects/smart-mail-agent-ssot-pro/.venv/lib/python3.10/site-packages/joblib/numpy_pickle.py", line 749, in load
    obj = _unpickle(
  File "/home/youjie/projects/smart-mail-agent-ssot-pro/.venv/lib/python3.10/site-packages/joblib/numpy_pickle.py", line 626, in _unpickle
    obj = unpickler.load()
  File "/usr/lib/python3.10/pickle.py", line 1213, in load
    dispatch[key[0]](self)
  File "/usr/lib/python3.10/pickle.py", line 1538, in load_stack_global
    self.append(self.find_class(module, name))
  File "/usr/lib/python3.10/pickle.py", line 1582, in find_class
    return _getattribute(sys.modules[module], name)[0]
  File "/usr/lib/python3.10/pickle.py", line 331, in _getattribute
    raise AttributeError("Can't get attribute {!r} on {!r}"
AttributeError: Can't get attribute 'rules_feat' on <module '__main__' (built-in)>
=== TRAP ===
TIME: 2025-09-14T20:40:28+08:00
BASH_COMMAND: R="$R" python - <<'PY'
import os, sys, json, traceback, shutil
from pathlib import Path
import importlib, importlib.util, types
import numpy as np, joblib
from scipy import sparse as sp

LOGDIR = Path(os.environ["R"])
def w(p, obj): Path(p).write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")
def wtxt(p, txt): Path(p).write_text(txt, encoding="utf-8")

# --- 環境快照 ---
env = {}
try:
    import sklearn, scipy
    env = {
        "python": sys.version.split()[0],
        "numpy": np.__version__,
        "scipy": scipy.__version__,
        "sklearn": sklearn.__version__,
        "joblib": joblib.__version__,
        "cwd": str(Path.cwd()),
    }
except Exception: pass
w(LOGDIR/"env.json", env)

# --- 找 PKL（優先你壓縮包那顆 intent_pro_cal.pkl） ---
cands = [
    Path("intent/intent/artifacts/intent_pro_cal.pkl"),
    Path("intent/artifacts/intent_pro_cal.pkl"),
    Path("intent/intent/artifacts/intent_pipeline_fixed.pkl"),
    Path("intent/artifacts/intent_pipeline_fixed.pkl"),
]
pkl = next((p for p in cands if p.exists()), None)
if not pkl:
    print("[FATAL] 找不到 intent/**/artifacts/*.pkl"); raise SystemExit(2)
print("[PKL]", pkl)

# --- CODE_ROOT：讓內部 import 有路徑可找 ---
code_roots = [Path("intent/intent"), Path("intent")]
CODE_ROOT = next((cr for cr in code_roots if cr.exists()), None)
print("[CODE_ROOT]", CODE_ROOT if CODE_ROOT else "<missing>")
if CODE_ROOT: sys.path.insert(0, str(CODE_ROOT.resolve()))

# --- 鎖定 rules_feat 真正來源檔（跳過 train_* 類檔案） ---
def choose_rules_file(root: Path|None) -> Path|None:
    if not root: return None
    prefer = ["rules_features.py", "threshold_router_runtime.py", "threshold_router.py"]
    for name in prefer:
        p = next(root.rglob(name), None)
        if p: return p
    # 備援：任何含 def rules_feat 的 .py，但排除 train/build/fresh
    for py in root.rglob("*.py"):
        nm = py.name.lower()
        if any(k in nm for k in ("train", "build", "fresh")): 
            continue
        try:
            txt = py.read_text(encoding="utf-8", errors="ignore")
            if "def rules_feat" in txt:
                return py
        except Exception:
            pass
    return None

rules_src = choose_rules_file(CODE_ROOT)

# --- 將 rules_src 複製成 vendor/rules_features.py，確保未來可被 import ---
vendor = Path("vendor"); vendor.mkdir(parents=True, exist_ok=True)
shim = vendor/"rules_features.py"
copied = False
if rules_src and rules_src.exists():
    try:
        shutil.copy2(rules_src, shim)
        copied = True
        print("[rules_feat] copied ->", shim)
    except Exception as e:
        print("[rules_feat_copy_fail]", type(e).__name__, e)

# 若找不到，就寫最小 shim（輸出 1 維零特徵；效果會差，但至少能載入）
if not copied:
    shim.write_text(
        "from scipy import sparse as sp\n"
        "def rules_feat(texts):\n"
        "    n = len(texts)\n"
        "    return sp.csr_matrix((n,1))\n",
        encoding="utf-8"
    )
    print("[rules_feat] shim(minimal) ->", shim)

# 把 vendor 放進 sys.path 並註冊別名模組名，避免舊 pickle 的 module 路徑對不上
if str(vendor.resolve()) not in sys.path:
    sys.path.insert(0, str(vendor.resolve()))
rf = importlib.import_module("rules_features")
aliases = [
    "rules_features",
    "intent_bundle.threshold_router_runtime",
    "intent_bundle_intent__sma_tools_runtime_threshold_router_py",
    "sma_tools.threshold_router",
]
for name in aliases:
    sys.modules[name] = rf

# --- 載入 PKL（此時 rules_feat / ZeroPad 都就位） ---
try:
    obj = joblib.load(pkl)
except Exception as e:
    Path(LOGDIR/"last_trace.txt").write_text(traceback.format_exc(), encoding="utf-8")
    print("[LOAD_FAIL]", type(e).__name__, e); raise SystemExit(3)

# unwrap
est = obj
if isinstance(obj, dict):
    for k in ("pipe","pipeline","estimator","clf","model"):
        if k in obj and hasattr(obj[k], "predict"): est = obj[k]; break
if not hasattr(est, "predict"):
    print("[FATAL] 不是可推論的 estimator"); raise SystemExit(4)

# 找 features union 與分類器
pre = None; clf = est
if hasattr(est, "steps"):
    print("steps:", [(n, s.__class__.__name__) for n,s in est.steps])
    pre = dict(est.steps).get("features") or dict(est.steps).get("pre") or dict(est.steps).get("union")
    clf = est.steps[-1][1]

# 期望維度
expected = None
if hasattr(clf, "n_features_in_"): expected = int(clf.n_features_in_)
elif hasattr(clf, "base_estimator") and hasattr(clf.base_estimator, "n_features_in_"):
    expected = int(clf.base_estimator.n_features_in_)
print("[EXPECTED]", expected)

# 估各分支實際輸出
def as_csr(Y):
    if sp.issparse(Y): return Y.tocsr()
    if isinstance(Y, np.ndarray): return sp.csr_matrix(Y if Y.ndim==2 else Y.reshape(1,-1))
    if isinstance(Y, list): return sp.csr_matrix((len(Y), 1))
    raise TypeError(f"non-numeric output: {type(Y).__name__}")

branch_dims = {}
probe = ["報價與交期", "技術支援", "發票抬頭", "退訂連結"]
if pre and hasattr(pre, "transformer_list"):
    for name, sub in pre.transformer_list:
        try:
            Y = as_csr(sub.transform(probe))
            branch_dims[name] = int(Y.shape[1])
        except Exception as e:
            branch_dims[name] = f"ERR:{type(e).__name__}"
print("[BRANCH_DIMS]", json.dumps(branch_dims, ensure_ascii=False))
sum_before = sum(v for v in branch_dims.values() if isinstance(v,int))
print("[SUM_BEFORE]", sum_before)

# 對齊欄位數
delta = None if expected is None or not sum_before else (expected - sum_before)
fixed = False
if delta and pre and hasattr(pre, "transformer_list"):
    for i,(name, sub) in enumerate(pre.transformer_list):
        if hasattr(sub, "width"):
            try:
                old = int(getattr(sub,"width",1) or 1)
                setattr(sub, "width", old + int(delta))
                pre.transformer_list[i] = (name, sub)
                print(f"[PAD_ADD] {name}: +{int(delta)} (from {old} -> {old+int(delta)})")
                fixed = True
                break
            except Exception as e:
                print("[PAD_FIX_FAIL]", name, type(e).__name__, e)
    if not fixed:
        from sma_tools.sk_zero_pad import ZeroPad
        pre.transformer_list.append(("pad_auto", ZeroPad(width=int(delta))))
        print(f"[PAD_ADD] pad_auto: +{int(delta)}")
        fixed = True

# 落地診斷
diag = {
    "pkl_path": str(pkl),
    "code_root": (str(CODE_ROOT) if CODE_ROOT else None),
    "rules_src": (str(rules_src) if rules_src else None),
    "rules_features_vendor": "vendor/rules_features.py",
    "expected_dim": expected,
    "branch_dims": branch_dims,
    "sum_before": sum_before,
    "delta": (int(delta) if isinstance(delta,(int,np.integer)) else None),
    "fixed": fixed,
}
w(LOGDIR/"diagnostics.json", diag)

# 存 aligned 版
out = Path("artifacts/intent_pipeline_aligned.pkl")
try:
    joblib.dump(est, out)
    print("[SAVED]", out)
except Exception as e:
    Path(LOGDIR/"last_trace.txt").write_text(traceback.format_exc(), encoding="utf-8")
    print("[SAVE_FAIL]", type(e).__name__, e)

# 煙囪測（中文）
to_zh = {"biz_quote":"報價","tech_support":"技術支援","complaint":"投訴","policy_qa":"規則詢問","profile_update":"資料異動","other":"其他"}
tests = ["您好，想詢問報價與交期","請協助開立三聯發票抬頭","需要技術支援協助，附件連不上","退訂連結在此"]
try:
    yp = est.predict(tests)
    sm = {"samples": tests, "pred": [str(x) for x in yp]}
    for s,y in zip(tests, yp):
        print("   ", s, "->", f"{y} / {to_zh.get(str(y), str(y))}")
    w(LOGDIR/"sample_pred.json", sm)
except Exception as e:
    Path(LOGDIR/"last_trace.txt").write_text(traceback.format_exc(), encoding="utf-8")
    print("[PRED_FAIL]", type(e).__name__, e)

print("[DONE] see:", LOGDIR)
PY

EXIT_CODE: 3
