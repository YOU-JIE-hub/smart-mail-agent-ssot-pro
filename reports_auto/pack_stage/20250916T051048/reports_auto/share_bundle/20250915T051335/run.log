[*] LOGDIR = reports_auto/share_bundle/20250915T051335

[*] æ‰“åŒ… ZIPï¼šreports_auto/share_bundle/20250915T051335/bundle.zip
-rw-r--r-- 1 youjie youjie 59M Sep 15 05:13 reports_auto/share_bundle/20250915T051335/bundle.zip
[?2004h(.venv) ]0;youjie@DESKTOP-MP3QVS6: ~/projects/smart-mail-agent-ssot-pro[01;32myoujie@DESKTOP-MP3QVS6[00m:[01;34m~/projects/smart-mail-agent-ssot-pro[00m$ # é€²å…¥ä½ çš„å°ˆæ¡ˆä¸¦å•Ÿç”¨ç’°å¢ƒï¼ˆä½ å›ºå®šè¦æ±‚çš„å‰ç½®ï¼‰
cd ~/projects/smart-mail-agent-ssot-pro; [ -f .venv/bin/activate ] && . .venv/bin/activate || true
export PYTHONNOUSERSITE=1 PYTHONPATH="src:${PYTHONPATH:-}"
export SMA_SMTP_MODE="${SMA_SMTP_MODE:-outbox}" SMA_LLM_PROVIDER="${SMA_LLM_PROVIDER:-none}"

# å»ºç«‹ä¸€éµç›¤é»è…³æœ¬
mkdir -p scripts tools vendor/sma_tools reports_auto
cat > scripts/sma_probe_all.sh <<'BASH'
#!/usr/bin/env bash
set -Eeuo pipefail -o errtrace

# === åŸºæœ¬è·¯å¾‘èˆ‡è¼¸å‡º ===
ROOT="${ROOT:-$PWD}"
TS="$(date +%Y%m%dT%H%M%S)"
OUT="reports_auto/probe/${TS}"
LOG="${OUT}/run.log"
ERR="${OUT}/probe.err"
mkdir -p "${OUT}"

# === é€šç”¨ trapï¼šå–®ä¸€ .err + è‡ªå‹•é–‹è³‡æ–™å¤¾ ===
on_err() {
  ec=$?
  {
    echo "TIME: $(date -Is)"
    echo "EXIT_CODE: $ec"
    echo "BASH_COMMAND: ${BASH_COMMAND:-<none>}"
  } >"${ERR}" || true
  echo "[FAIL] details in ${ERR}"
  if command -v explorer.exe >/dev/null 2>&1; then explorer.exe "$(wslpath -w "${OUT}")" >/dev/null 2>&1 || true
  elif command -v xdg-open >/dev/null 2>&1; then xdg-open "${OUT}" >/dev/null 2>&1 || true
  fi  exit $ec}trap on_err ERRtrap ' { echo "[*] REPORT: ${OUT}"; if command -v explorer.exe >/dev/null 2>&1; then explorer.exe "$(wslpath -w "${OUT}")" >/dev/null 2>&1 || true; elif command -v xdg-open >/dev/null 2>&1; then xdg-open "${OUT}" >/dev/null 2>&1 || true; fi; } ' EXIT# === æœ€å° ZeroPad ä¾›ååºåˆ—åŒ–ç”¨ï¼ˆä¸æ”¹å¯¬åº¦ï¼Œä¸æ”¹æ ¸å¿ƒç¢¼ï¼‰ ===mkdir -p vendor/sma_toolsif [ ! -f vendor/sma_tools/__init__.py ]; then printf '__all__=["sk_zero_pad"]\n' > vendor/sma_tools/__init__.py; ficat > vendor/sma_tools/sk_zero_pad.py <<'PY'from __future__ import annotationsimport numpy as npfrom scipy import sparse as spfrom sklearn.base import BaseEstimator, TransformerMixinclass ZeroPad(BaseEstimator, TransformerMixin):    def __init__(self, width:int=1, dtype=np.float64, **kwargs):        try: self.width = int(width) if width else 1        except Exception: self.width = 1        self.dtype = dtype        self._extra = dict(kwargs)    def __setstate__(self, state):        self.__dict__.update(state or {})        if not hasattr(self,"width"): self.width = 1        if not hasattr(self,"dtype"): self.dtype = np.float64    def fit(self, X, y=None): return self    def transform(self, X): return sp.csr_matrix((len(X), self.width), dtype=self.dtype)PY# === Python ç›¤é»ï¼šæƒæ + è¼•é‡å˜—è©¦è¼‰å…¥ ===python - <<'PY' "${OUT}"import os, sys, json, glob, traceback, sqlite3, faulthandlerfrom pathlib import PathR = Path(sys.argv[1]); R.mkdir(parents=True, exist_ok=True)pylog = open(R/"py_run.log","w",encoding="utf-8"); faulthandler.enable(pylog)def log(*a): print(*a); print(*a,file=pylog,flush=True)# ç’°å¢ƒå¿«ç…§env = {  "cwd": os.getcwd(),  "python": sys.version.split()[0],  "numpy": __import__("numpy").__version__ if "numpy" in sys.modules or True else None,  "scipy": __import__("scipy").__version__ if "scipy" in sys.modules or True else None,  "sklearn": __import__("sklearn").__version__ if "sklearn" in sys.modules or True else None,  "joblib": __import__("joblib").__version__ if "joblib" in sys.modules or True else None,  "PYTHONPATH": os.environ.get("PYTHONPATH",""),  "SMA_EML_DIR": os.environ.get("SMA_EML_DIR","")}(R/"env_snapshot.json").write_text(json.dumps(env,ensure_ascii=False,indent=2),encoding="utf-8")missing = []             # å¾…è£œæ¸…å–®ï¼ˆä½ è¦å›å‚³çµ¦æˆ‘çš„ï¼‰findings = {"intent":{}, "spam":{}, "kie":{}, "configs":{}, "db":{}, "alerts":[]}# â€”â€” Intent æ¨¡å‹èˆ‡è³‡æ–™ â€”â€” #def list_candidates():  c = []  c += glob.glob("artifacts/intent_*.pkl")  c += glob.glob("intent/**/artifacts/intent_pro_cal.pkl", recursive=True)  c += glob.glob("artifacts_prod/**/intent*.pkl", recursive=True)  return sorted(set(c))def bind_rules_from_bundle():  # å¸¸è¦‹è¨“ç·´æ™‚çš„ rules æª”  cands = sorted(glob.glob("intent/**/.sma_tools/runtime_threshold_router.py", recursive=True))  if not cands: return None  src = Path(cands[-1]).resolve()  code = src.read_text(encoding="utf-8", errors="replace")  import types  names = [    "train_pro","train_pro_fresh",    "sma_tools.runtime_threshold_router","runtime_threshold_router",    "vendor.rules_features"  ]  for nm in names:    m = types.ModuleType(nm); sys.modules[nm]=m    exec(compile(code,str(src),"exec"),m.__dict__,m.__dict__)  import __main__ as M  M.rules_feat = sys.modules[names[-1]].__dict__.get("rules_feat",None)  return str(src)rules_src = bind_rules_from_bundle()findings["intent"]["rules_module"] = rules_src or "NOT_FOUND"if not rules_src:  findings["alerts"].append("intent.rules: runtime_threshold_router.py æœªæ‰¾åˆ°ï¼Œå¯èƒ½å°è‡´ç‰¹å¾µå°é½Šå¤±æ•—")  missing.append({"need":"intent rules module (.sma_tools/runtime_threshold_router.py)","where":"intent/**/.sma_tools/","why":"ç¢ºä¿èˆ‡è¨“ç·´æœŸç‰¹å¾µå®Œå…¨ä¸€è‡´"})# å˜—è©¦è¼‰å…¥æ¯é¡†æ„åœ–æ¨¡å‹ï¼Œæª¢æŸ¥ n_features èˆ‡åˆ†æ”¯ç¶­åº¦import joblib, numpy as npfrom scipy import sparse as spdef try_probe_intent(pkl):  info = {"path":pkl,"load_ok":False,"msg":"","steps":[], "n_features_in":None, "branch_dims":{}, "sum_branch":None}  try:    obj = joblib.load(pkl)    # unwrap    est = obj    if isinstance(obj, dict):      for k in ("pipe","pipeline","estimator","clf","model"):        if k in obj and hasattr(obj[k],"predict"): est = obj[k]    info["steps"] = [(n, type(s).__name__) for n,s in getattr(est, "steps",[])]    clf = est.steps[-1][1] if hasattr(est,"steps") else est    nf = getattr(clf,"n_features_in_",None)    if nf is None and hasattr(clf,"base_estimator"): nf = getattr(clf.base_estimator,"n_features_in_",None)    info["n_features_in"] = int(nf) if nf is not None else None    # å˜—è©¦å° features union åš transform æ¸¬ç¶­åº¦    feats = None    if hasattr(est,"steps"):      d = dict(est.steps)      feats = d.get("features") or d.get("pre") or d.get("union")    if feats and hasattr(feats,"transformer_list"):      xs = ["å ±åƒ¹èˆ‡äº¤æœŸ","æŠ€è¡“æ”¯æ´","ç™¼ç¥¨æŠ¬é ­","é€€è¨‚é€£çµ"]      dims={}      for name,sub in feats.transformer_list:        try:          X = sub.transform(xs)          X = X.tocsr() if sp.issparse(X) else sp.csr_matrix(X if isinstance(X,np.ndarray) else [[0]])          dims[name] = int(X.shape[1])        except Exception as e:          dims[name] = f"ERR:{type(e).__name__}"      info["branch_dims"] = dims      s = sum(v for v in dims.values() if isinstance(v,int))      info["sum_branch"] = s    info["load_ok"] = True  except Exception as e:    info["msg"] = f"{type(e).__name__}: {e}"  return infointent_pkls = list_candidates()findings["intent"]["candidates"] = intent_pklsprobe_results = [try_probe_intent(p) for p in intent_pkls]findings["intent"]["probes"] = probe_resultsif not intent_pkls:  findings["alerts"].append("intent.pkl æœªæ‰¾åˆ°")  missing.append({"need":"intent_pro_cal.pkl æˆ– artifacts/intent_*.pkl","where":"intent/**/artifacts æˆ– artifacts/","why":"å•Ÿç”¨ ML è·¯ç·šä¸¦åšä¸‰è·¯æ¯”è¼ƒ"})# æ„åœ–è³‡æ–™é›†ds = Path("data/intent_eval/dataset.cleaned.jsonl")if ds.exists():  labels=set(); n=0  for ln in ds.read_text(encoding="utf-8", errors="replace").splitlines():    if not ln.strip(): continue    try:      d=json.loads(ln); n+=1      lab = d.get("label") or d.get("intent") or ""      if lab!="": labels.add(str(lab))    except: pass  findings["intent"]["dataset"] = {"path":str(ds),"n":n,"labels":sorted(labels)}else:  missing.append({"need":"intent è©•æ¸¬é›† dataset.cleaned.jsonl","where":"data/intent_eval/","why":"é›¢ç·šçµ±ä¸€æŒ‡æ¨™/æ··æ·†çŸ©é™£"})# â€”â€” Spam â€”â€” #spam_pkls = sorted(set(glob.glob("artifacts/**/spam*.pkl", recursive=True) + glob.glob("artifacts_inbox/**/spam*.pkl", recursive=True)))findings["spam"]["candidates"] = spam_pklsif not spam_pkls:  findings["alerts"].append("spam.pkl æœªæ‰¾åˆ°ï¼ˆæˆ–æœªç´¢å¼•åˆ° artifacts_inbox/**ï¼‰")ens = Path("artifacts_prod/ens_thresholds.json")if ens.exists():  try: findings["spam"]["ens_thresholds.json"] = json.loads(ens.read_text(encoding="utf-8"))  except Exception as e:    findings["spam"]["ens_thresholds.json"] = f"JSON_ERROR:{e}"else:  missing.append({"need":"ens_thresholds.json","where":"artifacts_prod/","why":"Spam é–€æª»æ ¡æ­£é‡ç¾"})# â€”â€” KIE â€”â€” #kie_model_dirs = sorted({str(Path(p).parent) for p in glob.glob("artifacts_inbox/**/kie*/model", recursive=True)})findings["kie"]["model_dirs"] = kie_model_dirsgold = Path("data/kie_eval/gold_merged.jsonl")for_eval = Path("data/kie/test_real.for_eval.jsonl")kie_info={}if gold.exists():  kie_info["gold_merged.jsonl_lines"] = sum(1 for _ in gold.open(encoding="utf-8", errors="ignore"))else:  missing.append({"need":"gold_merged.jsonl","where":"data/kie_eval/","why":"KIE æ¬„ä½ç´šæŒ‡æ¨™"})if for_eval.exists():  kie_info["for_eval.jsonl_lines"] = sum(1 for _ in for_eval.open(encoding="utf-8", errors="ignore"))else:  findings["alerts"].append("KIE for_eval æ¸¬è³‡æœªè¦‹ï¼ˆå¯é¸ï¼‰")findings["kie"]["datasets"]=kie_info# â€”â€” Configs â€”â€” #configs = {  "intent_rules_calib": sorted(glob.glob("**/intent_rules_calib*.json", recursive=True)),  "kie_runtime_config": sorted(glob.glob("**/kie_runtime_config*.json", recursive=True)),  "intent_contract": sorted(glob.glob("**/intent_contract*.json", recursive=True)),}findings["configs"]["paths"]=configsfor key, lst in configs.items():  if not lst:    missing.append({"need":f"{key}.json","where":"å°ˆæ¡ˆå…§å°æ‡‰è·¯å¾‘","why":"å°é½Šè¨“ç·´/æ¨è«–æœŸå¥‘ç´„"})  else:    # å˜—è©¦è¼‰å…¥ç¬¬ä¸€å€‹    f = Path(lst[0])    try:      findings["configs"][key] = json.loads(f.read_text(encoding="utf-8", errors="replace"))    except Exception as e:      findings["configs"][key] = f"JSON_ERROR:{e}"# â€”â€” DB å¯©è¨ˆ â€”â€” #dbp = Path("reports_auto/audit.sqlite3")if dbp.exists():  try:    con = sqlite3.connect(dbp); cur = con.cursor()    cur.execute("SELECT name FROM sqlite_master WHERE type='table'"); tbls = [r[0] for r in cur.fetchall()]    findings["db"]["tables"]=tbls    needed = ["llm_calls","actions","mails"]    for t in needed:      if t not in tbls:        findings["alerts"].append(f"DB è¡¨ç¼ºå¤±: {t}")        missing.append({"need":t,"where":"reports_auto/audit.sqlite3","why":"å¯©è¨ˆèˆ‡å†ªç­‰ç´€éŒ„"})  except Exception as e:    findings["db"]["error"]=f"{type(e).__name__}: {e}"else:  missing.append({"need":"audit.sqlite3","where":"reports_auto/","why":"å¯©è¨ˆ/æˆæœ¬/å»¶é²/è¡Œç‚ºçµæœ"})# â€”â€” å ±å‘Šè¼¸å‡º â€”â€” #(R/"probe_findings.json").write_text(json.dumps(findings,ensure_ascii=False,indent=2),encoding="utf-8")req = {  "please_provide": missing,  "notes": findings["alerts"],  "intent_models": findings["intent"].get("candidates",[]),  "spam_models": findings["spam"].get("candidates",[]),  "kie_models": findings["kie"].get("model_dirs",[])}(R/"REQUEST_missing_items.json").write_text(json.dumps(req,ensure_ascii=False,indent=2),encoding="utf-8")# ç”¢ Markdown çµ¦ä½ ç›´æ¥è²¼å›/ä¸Šå‚³md = ["# è³‡æ–™ç›¤é»èˆ‡å¾µé›†å ±å‘Š",      f"- ç›®éŒ„: {R}",      "## å¾…è£œæ¸…å–®ï¼ˆè«‹å›å‚³/æ”¾ç½®ï¼‰:"][7mfor i,x in enumerate(missing,1):[27m[7m  md.append(f"{i}. **{x['need']}** â†’ æ”¾åœ¨ `{x['where']}` ï¼›ç”¨é€”ï¼š{x['why']}")[27m[7mmd += ["","## é‡è¦æé†’:"][27m[7mfor a in findings["alerts"]:[27m[7m  md.append(f"- {a}")[27m[7mmd += ["","## Intent æ¨¡å‹å€™é¸:"] + [f"- {p}" for p in findings["intent"].get("candidates",[])][27m[7mmd += ["","## Spam æ¨¡å‹å€™é¸:"] + [f"- {p}" for p in findings["spam"].get("candidates",[])][27m[7mmd += ["","## KIE æ¨¡å‹ç›®éŒ„:"] + [f"- {p}" for p in findings["kie"].get("model_dirs",[])][27m[7mmd += ["","## Intent æ¨¡å‹æ¢æ¸¬ï¼ˆç¯€é¸ï¼‰:"][27m[7mfor pr in findings["intent"].get("probes",[])[:5]:[27m[7m  md.append(f"- `{pr['path']}` | load_ok={pr['load_ok']} | n_features_in={pr['n_features_in']} | sum_branch={pr['sum_bra[27m[7mnch']} | steps={pr['steps']} | branch_dims={pr['branch_dims']}")[27m[7m(Path(R/"REQUEST_missing_items.md")).write_text("\n".join(md),encoding="utf-8")[27m[7mprint("[OK] probe done at", R, file=pylog)[27m[7mPY[27m[7m# tee ç´€éŒ„ä¸¦åŸ·è¡Œ[27m[7mbash -lc 'echo "[*] Probingâ€¦ output -> '"${OUT}"'"; true' | tee "${LOG}"[27m[7mpython -c 'import sys; print("Python ready")' >> "${LOG}" 2>&1 || true[27m[7m# å®Œæˆæç¤ºï¼ˆEXIT trap æœƒè‡ªå‹•é–‹è³‡æ–™å¤¾ï¼‰[27m[7mecho "[DONE] See ${OUT}/REQUEST_missing_items.md and probe_findings.json" | tee -a "${LOG}"[27m[7mBASH[27m[7mchmod +x scripts/sma_probe_all.sh[27m[7m# ä¸€éµåŸ·è¡Œ[27m[7mscripts/sma_probe_all.sh[27mfor i,x in enumerate(missing,1):  md.append(f"{i}. **{x['need']}** â†’ æ”¾åœ¨ `{x['where']}` ï¼›ç”¨é€”ï¼š{x['why']}")md += ["","## é‡è¦æé†’:"]for a in findings["alerts"]:  md.append(f"- {a}")md += ["","## Intent æ¨¡å‹å€™é¸:"] + [f"- {p}" for p in findings["intent"].get("candidates",[])]md += ["","## Spam æ¨¡å‹å€™é¸:"] + [f"- {p}" for p in findings["spam"].get("candidates",[])]md += ["","## KIE æ¨¡å‹ç›®éŒ„:"] + [f"- {p}" for p in findings["kie"].get("model_dirs",[])]md += ["","## Intent æ¨¡å‹æ¢æ¸¬ï¼ˆç¯€é¸ï¼‰:"]for pr in findings["intent"].get("probes",[])[:5]:  md.append(f"- `{pr['path']}` | load_ok={pr['load_ok']} | n_features_in={pr['n_features_in']} | sum_branch={pr['sum_branch']} | steps={pr['steps']} | branch_dims={pr['branch_dims']}")(Path(R/"REQUEST_missing_items.md")).write_text("\n".join(md),encoding="utf-8")print("[OK] probe done at", R, file=pylog)PY# tee ç´€éŒ„ä¸¦åŸ·è¡Œbash -lc 'echo "[*] Probingâ€¦ output -> '"${OUT}"'"; true' | tee "${LOG}"python -c 'import sys; print("Python ready")' >> "${LOG}" 2>&1 || true# å®Œæˆæç¤ºï¼ˆEXIT trap æœƒè‡ªå‹•é–‹è³‡æ–™å¤¾ï¼‰echo "[DONE] See ${OUT}/REQUEST_missing_items.md and probe_findings.json" | tee -a "${LOG}"BASHchmod +x scripts/sma_probe_all.sh# ä¸€éµåŸ·è¡Œscripts/sma_probe_all.sh
[?2004lTraceback (most recent call last):
  File "<stdin>", line 49, in <module>
  File "<stdin>", line 44, in bind_rules_from_bundle
  File "/home/youjie/projects/smart-mail-agent-ssot-pro/intent/intent/.sma_tools/runtime_threshold_router.py", line 9, in <module>
    sys.path.insert(0, str(_P(__file__).resolve().parents[1] / '.sma_tools'))
NameError: name '__file__' is not defined. Did you mean: '__name__'?
[FAIL] details in reports_auto/probe/20250915T055021/probe.err
[*] REPORT: reports_auto/probe/20250915T055021
[*] æ‰“åŒ…å®Œæˆï¼Œç›®éŒ„ï¼šreports_auto/share_bundle/20250915T051335
