from __future__ import annotations
import json, sqlite3, time
from pathlib import Path
from typing import Dict, Any
SCHEMA = """
CREATE TABLE IF NOT EXISTS runs     (ts INTEGER PRIMARY KEY, note TEXT);
CREATE TABLE IF NOT EXISTS mails    (mail_id TEXT PRIMARY KEY, subject TEXT, ts INTEGER);
CREATE TABLE IF NOT EXISTS intent_preds(mail_id TEXT, final TEXT, p1 REAL);
CREATE TABLE IF NOT EXISTS kie_spans(mail_id TEXT, label TEXT, start INT, end INT);
CREATE TABLE IF NOT EXISTS actions  (mail_id TEXT, action TEXT, priority TEXT, queue TEXT, ts INTEGER);
CREATE TABLE IF NOT EXISTS err_log  (ts INTEGER, mail_id TEXT, stage TEXT, message TEXT, traceback TEXT);
"""
class Audit:
    def __init__(self, project_root: Path):
        self.root = Path(project_root); self.db = self.root/"db/sma.sqlite"; self.nd = self.root/"reports_auto/logs/pipeline.ndjson"
        self.db.parent.mkdir(parents=True, exist_ok=True); self.nd.parent.mkdir(parents=True, exist_ok=True)
        con = sqlite3.connect(self.db); con.executescript(SCHEMA); con.commit(); con.close()
    def log(self, stage: str, level: str, meta: Dict[str,Any]) -> None:
        rec = {"ts": int(time.time()), "stage": stage, "level": level, **meta}
        with self.nd.open("a", encoding="utf-8") as f: f.write(json.dumps(rec, ensure_ascii=False) + "\n")
        try:
            con = sqlite3.connect(self.db); cur = con.cursor()
            if stage=="ingest" and "mail_id" in meta:
                cur.execute("INSERT OR IGNORE INTO mails(mail_id,subject,ts) VALUES(?,?,?)",(meta.get("mail_id"), meta.get("subject",""), rec["ts"]))
            if stage=="action" and {"mail_id","action","priority","queue"} <= meta.keys():
                cur.execute("INSERT INTO actions(mail_id,action,priority,queue,ts) VALUES(?,?,?,?,?)",(meta["mail_id"], meta["action"], meta["priority"], meta["queue"], rec["ts"]))
            con.commit()
        except Exception:
            pass
        finally:
            try: con.close()
            except Exception: pass
